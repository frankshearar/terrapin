<html>
  <head>
    <title>Terrapin</title>
    <style type="text/css">
div {
  display: block;
}

.gridline {
  stroke: rgb(0,0,0);
  stroke-width: 2;
}

.plane {
  height: 400px;
  width: 400px;
}

#z-plane {
  float: left;
}

#w-plane {
  float: right;
}
    </style>
    <script type="text/javascript" src="./d3.v2.js"></script>
  </head>
  <body>
    <div id="complex-transform">
	<p>Represent complex numbers <i>z</i> as pairs <code>[x, y]</code>. Transform these through some complex-valued function <i>f</i>, and graphically represent <i>f</i>'s action by showing how vertical and horizontal lines are transformed.</p>
	<p>In particular, we show below linear fractional transformations, transformations of the form f(z) = (az + b) / (cz + d) where a, b, c, d &isin; C, the set of complex numbers.</p>
	<div id="value-store">
          <table>
	    <thead><td>Variable</td><td>Real component</td><td>Imaginary component</td></thead>
	    <tr><td>a</td><td><input type="text" id="a_r" name="a_r" value="1"/></td><td><input type="text" id="a_i" name="a_i" value="0"/></td></tr>
	    <tr><td>b</td><td><input type="text" id="b_r" name="b_r" value="0"/></td><td><input type="text" id="b_i" name="b_i" value="0"/></td></tr>
	    <tr><td>c</td><td><input type="text" id="c_r" name="c_r" value="0"/></td><td><input type="text" id="c_i" name="c_i" value="0"/></td></tr>
	    <tr><td>d</td><td><input type="text" id="d_r" name="d_r" value="1"/></td><td><input type="text" id="d_i" name="d_i" value="0"/></td></tr>
	  </table>
          <button id="go-button">Go</button>
	</div>
      <div id="z-plane" class="plane"></div>
      <div id="w-plane" class="plane"></div>
      <script type="text/javascript">
function makePlane(planeName) {
  return d3.select(planeName).append("svg")
    .attr("height", h)
    .attr("width", w)
    .append("g")
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke", "black");

/*
  svg = d3.select(planeName).append("svg")
    .attr("height", h)
    .attr("width", w);
//  svg.append("defs").append("clipPath")
//    .append("rect")
//    .attr("height", h)
//    .attr("width", w);
    
  svg.append("g")
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke", "black");

  return svg;
*/
}

function memoise_f() {
  a = [parseInt(document.getElementById("a_r").value), parseInt(document.getElementById("a_i").value)];
  b = [parseInt(document.getElementById("b_r").value), parseInt(document.getElementById("b_i").value)];
  c = [parseInt(document.getElementById("c_r").value), parseInt(document.getElementById("c_i").value)];
  d = [parseInt(document.getElementById("d_r").value), parseInt(document.getElementById("d_i").value)];
  return function(z) {
    return moebius(z, a, b, c, d);
  }
}

// Initial conditions, data.
var h = 400;
var w = h;
var f = memoise_f();

var min_x = -2, max_x = 2
var grid = d3.range(min_x, max_x + 1, 0.1);
var x = d3.scale.linear()
  .domain([min_x, max_x])
  .range([0, h]);
var y = d3.scale.linear()
  .domain([min_x, max_x])
  .range([h, 0]); // Invert the scale so the origin is in the BOTTOM left corner
var lineMaker = d3.svg.line()
    .x(function(d) { return x(d[0]); })
    .y(function(d) { return y(d[1]); });

function complex(real, imaginary) {
  return [real, imaginary];
}

function hlines(range_of_values) {
  return range_of_values.map(function(i) {
    return range_of_values.map(function(j) {
      return complex(j, i);
    });
  });
}

function vlines(range_of_values) {
  return range_of_values.map(function(i) {
    return range_of_values.map(function(j) {
      return complex(i, j);
    });
  });
}

function make_grid(range_of_values) {
  return hlines(range_of_values).concat(vlines(range_of_values));
}

var zlines = make_grid(grid);
var wlines = make_grid(grid);

var zplane = makePlane("#z-plane", h, w, zlines);
var wplane = makePlane("#w-plane", h, w, hlines);

makeLines(zplane, zlines);
makeLines(wplane, wlines);

d3.select("#go-button").on("click", function() {
  f = memoise_f();

  if (a*d - b*c < 1e6) {
    alert("Not a Moebius transform!");
  }

  // Mutate the w-plane data in place do d3 can automatically pick up the changes.
  for (var lineI = 0; lineI < wlines.length; lineI++) {
    for (var pointI = 0; pointI < wlines[lineI].length; pointI++) {
      wlines[lineI][pointI] = f(zlines[lineI][pointI]);
    }
  }
  drawLines(wplane, wlines);
});

function drawLines(planeDiv, arr) {
  planeDiv.selectAll(".line")
    .transition()
    .ease("linear")
    .attr("d", lineMaker);
}

function makeLines(planeDiv, arr) {
  planeDiv.selectAll(".line")
    .data(arr)
    .enter().append("path")
      .attr("class", "line")
      .attr("d", lineMaker);
}

// c_mult :: C -> C -> C
function c_mult(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return complex(a*c - b*d, a*d + b*c);
}

// c_add :: C -> C -> C
function c_add(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return complex(a + c, b + d);
}

// c_div :: C -> C -> C
function c_div(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return complex((a*c + b*d) / c*c + d*d , (b*c - a*d) / c*c + d*d);
}

// moebius :: C -> C -> C -> C -> C
function moebius(z, a, b, c, d) {
  // f(z) = (az + b) / (cz + d)
  if (z == Infinity) {
    return (c == 0) ? Infinity : c_div(a, c);
  } else {
    return c_div((c_add(c_mult(a, z), b)), (c_add(c_mult(c, z), d)));
  }
}
     </script>
    </div>
  </body>
</html>

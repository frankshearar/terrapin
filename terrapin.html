<html>
  <head>
    <title>Terrapin</title>
    <style type="text/css">
div {
  display: block;
}

.gridline {
  stroke: rgb(0,0,0);
  stroke-width: 2;
}

.plane {
  height: 400px;
  width: 400px;
}

#z-plane {
  float: left;
}

#w-plane {
  float: right;
}
    </style>
    <script type="text/javascript" src="./d3.v2.js"></script>
  </head>
  <body>
    <div id="complex-transform">
	<p>Represent complex numbers <i>z</i> as pairs <code>[x, y]</code>. Transform these through some complex-valued function <i>f</i>, and graphically represent <i>f</i>'s action by showing how vertical and horizontal lines are transformed.</p>
	<p>In particular, we show below linear fractional transformations, transformations of the form f(z) = (az + b) / (cz + d) where a, b, c, d &isin; C, the set of complex numbers.</p>
	<div id="value-store">
          <table>
	    <thead><td>Variable</td><td>Real component</td><td>Imaginary component</td></thead>
	    <tr><td>a</td><td><input type="text" id="a_r" name="a_r" value="1"/></td><td><input type="text" id="a_i" name="a_i" value="0"/></td></tr>
	    <tr><td>b</td><td><input type="text" id="b_r" name="b_r" value="0"/></td><td><input type="text" id="b_i" name="b_i" value="0"/></td></tr>
	    <tr><td>c</td><td><input type="text" id="c_r" name="c_r" value="0"/></td><td><input type="text" id="c_i" name="c_i" value="0"/></td></tr>
	    <tr><td>d</td><td><input type="text" id="d_r" name="d_r" value="1"/></td><td><input type="text" id="d_i" name="d_i" value="0"/></td></tr>
	  </table>
          <button id="go-button">Go</button>
	</div>
      <div id="z-plane" class="plane"></div>
      <div id="w-plane" class="plane"></div>
      <script type="text/javascript">
function makePlane(planeName) {
  return d3.select(planeName).append("svg")
    .attr("height", h)
    .attr("width", w)
    .append("g")
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke", "black")
    .attr("transform", "translate(" + h / 2 + ", " + h / 2 + ")");

/*
  svg = d3.select(planeName).append("svg")
    .attr("height", h)
    .attr("width", w);
//  svg.append("defs").append("clipPath")
//    .append("rect")
//    .attr("height", h)
//    .attr("width", w);
    
  svg.append("g")
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke", "black")
    .attr("transform", "translate(" + h / 2 + ", " + h / 2 + ")");

  return svg;
*/
}

function memoise_f() {
  a = [parseInt(document.getElementById("a_r").value), parseInt(document.getElementById("a_i").value)];
  b = [parseInt(document.getElementById("b_r").value), parseInt(document.getElementById("b_i").value)];
  c = [parseInt(document.getElementById("c_r").value), parseInt(document.getElementById("c_i").value)];
  d = [parseInt(document.getElementById("d_r").value), parseInt(document.getElementById("d_i").value)];
  f = function(z) {
    return moebius(z, a, b, c, d);
  }
}

// Initial conditions, data.
var h = 300;
var w = h;
var f = function(z) { return z; };

var min_x = -100, max_x = 100
var grid = d3.range(min_x, max_x + 1, 10);
var x = d3.scale.linear()
  .domain([min_x, max_x])
  .range([-h / 2, h / 2]);
var y = d3.scale.linear()
  .domain([min_x, max_x])
  .range([h / 2, -h / 2]); // Invert the scale so the origin is in the BOTTOM left corner

// TODO: This screams for an elegant function solution that
// I don't have time to think about right now.
var zlines = [];
var wlines = [];
grid.forEach(function(i) {
  vline = grid.map(function(j) {
    return [i, j];
  });
  hline = grid.map(function(j) {
    return [j, i];
  });
  zlines.push(vline);
  zlines.push(hline);
  wlines.push(vline);
  wlines.push(hline);
});

var zplane = makePlane("#z-plane", h, w);
var wplane = makePlane("#w-plane", h, w);

makeLines(zplane, zlines);
makeLines(wplane, wlines);

d3.select("#go-button").on("click", function() {
  a = [parseInt(document.getElementById("a_r").value), parseInt(document.getElementById("a_i").value)];
  b = [parseInt(document.getElementById("b_r").value), parseInt(document.getElementById("b_i").value)];
  c = [parseInt(document.getElementById("c_r").value), parseInt(document.getElementById("c_i").value)];
  d = [parseInt(document.getElementById("d_r").value), parseInt(document.getElementById("d_i").value)];
  f = function(z) {
    return moebius(z, a, b, c, d);
  }
  if (a*d - b*c < 1e6) {
    alert("Not a Moebius transform!");
  }

  // Mutate the w-plane data
  for (var lineI = 0; lineI < wlines.length; lineI++) {
    for (var pointI = 0; pointI < wlines[lineI].length; pointI++) {
      wlines[lineI][pointI] = f(zlines[lineI][pointI]);
    }
  }
  drawLines(wplane, wlines);
});

function drawLines(planeDiv, arr) {
  var line = d3.svg.line();

  planeDiv.selectAll(".line")
    .transition()
    .ease("linear")
    .attr("d", line);
}

function makeLines(planeDiv, arr) {
  var line = d3.svg.line();

  planeDiv.selectAll(".line")
    .data(arr)
    .enter().append("path")
      .attr("class", "line")
      .attr("d", line);
}

// c_mult :: C -> C -> C
function c_mult(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return [a*c - b*d, a*d + b*c];
}

// c_add :: C -> C -> C
function c_add(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return [a + c, b + d];
}

// c_div :: C -> C -> C
function c_div(z, w) {
  var a = z[0]; var b = z[1]; var c = w[0]; var d = w[1];
  return [(a*c + b*d) / c*c + d*d , (b*c - a*d) / c*c + d*d];
}

// moebius :: C -> C -> C -> C -> C
function moebius(z, a, b, c, d) {
  // f(z) = (az + b) / (cz + d)
  if (z == Infinity) {
    return (c == 0) ? Infinity : c_div(a, c);
  } else {
    return c_div((c_add(c_mult(a, z), b)), (c_add(c_mult(c, z), d)));
  }
}

// A line is an array of points, which are two-element arrays.
// f is a complex-valued function of one parameter.
function transformLine(line, f) {
  var lineInW = [];
  for (var i = 0; i < line.length; i++) {
    z = line[i];
    lineInW.push(f(z));
  }
  return lineInW;
}

// lines is an array of lines
function transformLines(lines, f) {
  var linesInW = [];
  for(var i = 0; i < lines.length; i++) {
    linesInW.push(transformLine(lines[i], f));
  }
  return linesInW;
}
     </script>
    </div>
  </body>
</html>
